from collections.abc import Iterable
from typing import Generic, TypeVar

from typing_extensions import Self, TypeAlias, override

from .core import Formula
from .operators import M_neg, M_le, M_min

T = TypeVar("T", covariant=True)

class Trace(Generic[T]):
    def __new__(cls, elements: dict[float, T]) -> Self: ...
    def __getitem__(self, value: float) -> T: ...
    def times(self) -> Iterable[float]: ...
    def states(self) -> Iterable[T]: ...
    def at_time(self, time: float) -> T | None: ...

class Predicate(Formula[dict[str, float], float]):
    def __new__(cls, coefficients: dict[str, float], constant: float) -> Self: ...
    @override
    def evaluate(self, trace: Trace[dict[str, float]]) -> Trace[float]: ...

S = TypeVar("S")

class Not(Formula[S, M_neg]):
    def __new__(cls, subformula: Formula[S, M_neg]) -> Self: ...
    @override
    def evaluate(self, trace: Trace[S]) -> Trace[M_neg]: ...

class And(Formula[S, M_le]):
    def __new__(cls, lhs: Formula[S, M_le], rhs: Formula[S, M_le]) -> Self: ...
    @override
    def evaluate(self, trace: Trace[S]) -> Trace[M_le]: ...

Bounds: TypeAlias = tuple[float, float]

class Always(Formula[S, M_min]):
    def __new__(cls, subformula: Formula[S, M_min], bounds: Bounds | None) -> Self: ...
    @override
    def evaluate(self, trace: Trace[S]) -> Trace[M_min]: ...
